package elixe.modules.misc;

import elixe.events.OnAttackEntityEvent;
import elixe.events.OnMoveEvent;
import elixe.events.OnPacketReceiveEvent;
import elixe.events.OnPacketSendEvent;
import elixe.modules.Module;
import elixe.modules.ModuleCategory;
import elixe.modules.option.ModuleBoolean;
import elixe.utils.misc.ChatUtils;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.material.Material;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S1BPacketEntityAttach;
import net.minecraft.util.BlockPos;

public class MushExploit extends Module {
	public MushExploit() {
		super("Mush Exploit", ModuleCategory.MISC);

		moduleOptions.add(stomperExploitOption);
		moduleOptions.add(hulkExploitOption);
	}

	boolean stomperExploit;
	ModuleBoolean stomperExploitOption = new ModuleBoolean("stomper exploit", false) {
		
		public void valueChanged() {
			stomperExploit = (boolean) this.getValue();
		}
	};

	boolean hulkExploit;
	ModuleBoolean hulkExploitOption = new ModuleBoolean("hulk exploit", false) {
		
		public void valueChanged() {
			hulkExploit = (boolean) this.getValue();
		}
	};

	boolean shouldGoUp = false, shouldGoDown = false;
	int preparingUpTicks = 0;
	boolean preparingToGoUp = false;

	double upStartY, downStartY;
	int exploitReason = -1; //0 = stomper, 1 = hulk

	int packetCool;

	@EventHandler
	private Listener<OnPacketReceiveEvent> onPacketReceiveEvent = new Listener<>(e -> {
		if (e.getPacket() instanceof S1BPacketEntityAttach) {
			if (hulkExploit) {
				S1BPacketEntityAttach packetAttach = (S1BPacketEntityAttach) e.getPacket();
				if (packetAttach.getVehicleEntityId() == mc.thePlayer.getEntityId()) {
					preparingToGoUp = true;
					upStartY = mc.thePlayer.posY;
					exploitReason = 1;
				}
			}
		}
	});

	@EventHandler
	private Listener<OnPacketSendEvent> onPacketSendEvent = new Listener<>(e -> {

		if (e.getPacket() instanceof C03PacketPlayer) {
			if (packetCool > 0) {
				packetCool--;
				return;
			}
			if (shouldGoUp) {
				shouldGoUp = false;
				int goUpHeight = getMaxHeight(false, upStartY);
				if (goUpHeight > 10) {
					e.cancel();
					goUpPackets(goUpHeight);
				} else {
					ChatUtils.message(mc, "sem espaço vertical suficiente");
				}
				
			} else if (shouldGoDown) {
				shouldGoDown = false;
				int goDownHeight = getMaxHeight(true, downStartY);
				if (goDownHeight != 0) {
					e.cancel();
					goDownPackets(goDownHeight);
				} else {
					ChatUtils.message(mc, "sem espaço vertical suficiente");
				}
				
			}
		}
	});

	@EventHandler
	private Listener<OnMoveEvent> onMoveEvent = new Listener<>(e -> {
		if (preparingToGoUp) {
			e.cancel();
			preparingUpTicks++;
			if (preparingUpTicks == 5) {
				preparingToGoUp = false;
				preparingUpTicks = 0;
				shouldGoUp = true;
			}
		}
	});

	@EventHandler
	private Listener<OnAttackEntityEvent> onAttackEntityEvent = new Listener<>(e -> {
		if (stomperExploit) {
			
			int goDownHeight = getMaxHeight(true, mc.thePlayer.posY);
			if (4 > goDownHeight) {				
				upStartY = mc.thePlayer.posY;
				exploitReason = 0;
				preparingToGoUp = true;
			} 
			
		}
	});

	private void goDownPackets(int goDownHeight) {

		ChatUtils.message(mc, "down -> " + goDownHeight);

		int rest = goDownHeight % 8;
		int yMultiplier = (goDownHeight - rest) / 8;
		for (int i = 1; yMultiplier >= i; i++) {
			packetCool++;
			if (rest == 0 && i == yMultiplier) {
				mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						downStartY - 8 * i, mc.thePlayer.posZ, true));
			} else {
				mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						downStartY - 8 * i, mc.thePlayer.posZ, false));
			}

		}
		if (rest != 0) {
			packetCool++;
			mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
					downStartY - (8 * yMultiplier) - rest, mc.thePlayer.posZ, true));
		}

		mc.thePlayer.setPosition(mc.thePlayer.posX, downStartY - (8 * yMultiplier) - rest, mc.thePlayer.posZ);

	}

	private void goUpPackets(int goUpHeight) {

		ChatUtils.message(mc, "up -> " + goUpHeight);
		int rest = goUpHeight % 10;
		int yMultiplier = (goUpHeight - rest) / 10;
		for (int i = 1; yMultiplier >= i; i++) {
			packetCool++;
			mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
					upStartY + 10 * i, mc.thePlayer.posZ, false));
		}
		if (rest != 0) {
			packetCool++;
			mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
					upStartY + (10 * yMultiplier) + rest, mc.thePlayer.posZ, false));
		}
		packetCool++;

		downStartY = upStartY + (10 * yMultiplier) + rest;
		mc.thePlayer.setPosition(mc.thePlayer.posX, downStartY, mc.thePlayer.posZ);
		
		if (exploitReason == 0) {
		shouldGoDown = true;
		}
	}

	private int getMaxHeight(boolean down, double y) {
		int hei = 0;

		for (int i = 1; 70 >= i; i++) {
			if (mc.theWorld.getBlockState(new BlockPos(mc.thePlayer.posX, down ? y - 1 : y + 2 + i, mc.thePlayer.posZ))
					.getBlock().getMaterial() == Material.air) {
				hei++;
			} else {
				break;
			}
		}

		return hei;
	}
}
